# Kafka 学习

资料来源：

    作者：半兽人
    链接：http://orchome.com/5
    来源：OrcHome
    著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


## 检查点

* kafka节点之间如何复制备份的？
* kafka消息是否会丢失？为什么？
* kafka最合理的配置是什么？
* kafka的leader选举机制是什么？
* kafka对硬件的配置有什么要求？
* kafka的消息保证有几种方式？

## 基础概念

Kafka 的基本作用：
1. 消息中间件
2. 分布式流处理平台
3. 数据存储

作为流处理平台，需要的能力：
1. 消息队列
2. 以`容错`的方式存储消息（流）
3. 在消息流发生时处理它们

Kafka 的优势：
1. 构建实时的流数据管道，可靠的获取系统和应用程序之间的数据。
2. 构建实时流的应用程序，对数据流进行转换或反应。

* Kafka作为一个集群运行在一个或多个服务器上。
* Kafka集群存储的消息是以topic为类别记录的。
* 每个消息是有一个key，一个value和时间戳构成的。

Kafka 的核心 API：
1. 应用程序使用`Producer API`发布消息到一个或者多个topic（主题队列）
2. 应用程序使用`Consumer API`来订阅一个或者多个topic，并消费。
3. 应用程序使用`Streams API`充当一个流处理器，从一个或多个topic消费输入流，
并产生一个输出流到一个或多个输出topic，有效的将输入流转换到输出流。
4. `Connector API`允许构建或运行可重复使用的生产者或消费者，将topic连接到现有的应用程序或数据系统。

Kafka Client 与 Server 之间通讯，通过`tcp`协议实现，简单、高性能并且和开发语言无关。

**Broker**

已发布的消息保存在一组服务器中，称之为 Kafka 集群。集群中每一个服务器都是一个代理（Broker）。
消费者可以订阅一个或者多个topic，并从Broker拉数据，从而消费这些已发布的消息。

### Topic 和 Log

对于每一个 Topic，Kafka 集群都会维护一个分区的 Log，该 Topic 中的每一条消息都会固定有序的存贮在对应的一个分区中，
同时分区会给改消息分配一个唯一的序列号，即为offset。Kafka 集群会保持所有消息，直到它们过期， 无论消息是否被消费。

消费者会持有这个消息的 offset，并通过改变 offset 来读取不同的消息。正常情况下，当消费者消费消息的时候，
offset 也会线性的增加。但实际使用中也允许消费者指定 offset 来读取较老的消息， 无论它是否被消费过。

记录在 Kafka 中的消息是不可变的，消费者的消费操作不会改变 Log 所记录的消息，所以多个消费者对同一消息的并发处理相互之间并不会受影响。

### Partition

在 Kafka 的一个 Topic 下会有多个 Partition。

Kafka中采用分区的设计有几个目的：
1. 可以处理更多的消息，不受单台服务器的限制。Topic拥有多个分区意味着它可以不受限的处理更多的数据。
2. 分区可以作为并行处理的单元，稍后会谈到这一点。

### Distribution

Log的分区被分布到集群中的多个服务器上。每个服务器处理它分到的分区。 
根据配置每个分区还可以复制到其它服务器作为备份容错。 每个分区有一个leader，
零或多个follower。Leader处理此分区的所有的读写请求，而follower被动的复制数据。
如果leader宕机，其它的一个follower会被推举为新的leader。 
一台服务器可能同时是一个分区的leader，另一个分区的follower。 
这样可以平衡负载，避免所有的请求都只让一台或者某几台服务器处理。

### Producers

* 生产者负责发布消息到某一个Topic
* 生产者也负责选择具体的分区方式来承载消息

### Consumers

通常来讲，消费模型可分为两种：
1. 队列

队列的方式，是一组消费者从服务器读取消息，一条消息只有其中一个消费者来处理。

2. 发布-订阅

发布订阅模式，消息被广播给所有的消费者，接受到消息的消费者都可以处理此消息。

Kafka 为这两种模型提供了单一的消费者抽象模型： 消费者组。消费者为自己标明一个消费者组，
一个发布在 Topic 上的消息会被分发到此消费者组中的一个消费者。

如果使用队列模型，则所有的消费者都在一个消费者组中。

如果使用发布订阅模型，则所有消费者都在不同的消费者组中。


更通用的， 我们可以创建一些消费者组作为逻辑上的订阅者。每个组包含数目不等的消费者，
 一个组内多个消费者可以用来扩展性能和容错。正如下图所示：

![消费者组](http://img.orchome.com:8888/group1/M00/00/01/KmCudlf7D-OAEjy8AABoxGLnMI4173.png)

**消息顺序**

Kafka 可以保证消息的顺序不变， 这点与传统消息系统一样。
但是传统的队列模型，虽然服务器端存储的消息是有序的，但发送给消费者是异步的方式，并不能保证消费者收到消息的先后顺序。

Kafka 在这上面的处理会更好一点。对于一个 Topic 的分区，能够保证消息只能由消费者组中的唯一一个消费者处理，所以即使多个消费者
并行的处理一个 Topic 的分区，他们处理的消息依然是有序的。但是，在跨分区处理的情况下，就不行了。所以如果想要顺序处理Topic 中的所有消息，
可以只提供一个分区。

### Kafka 的保证
* 生产者发送到一个特定的 Topic 的分区上，消息会按照它们的发送顺序依次加入。
* 消费者收到的消息也是此顺序。
* 如果一个 Topic 配置了复制因子（replication factor）为 N，那么可以允许N-1台服务器宕机而不丢失任何已提交的消息。

### Kafka 作为消息系统，与传统消息系统的异同

**相同点：**

传统的消息系统有两种模式：`队列`和`发布订阅`。
Kafka 的每个 topic 都具有这两种模式（通过消费者组来实现）

**不同点：**

传统的消息系统按顺序保存数据，如果多个消费者从队列消费，则服务器按存储顺序发送消息，但是，尽管服务器按顺序发，
消息异步传递到消费者端时，就不一定保证顺序了。

Kafka 则通过 Topic 和 Partition，既提供了顺序保证，也提供了负载均衡。每个 Partition 仅由同一个消费这组中的一个消费者
消费。并确保该消费者是该 Partition 的唯一消费者，并按顺序消费。每个 topic 有多个分区，则需要多个消费者做负载均衡。

*相同消费者组中不能有比分区更多的消费者，否则多出的消费者会一直处于空等待，不会收到消息。*

### Kakfa 作为一个存储系统

所有发布消息到`消息队列`和消费分离的系统，实际上都充当了一个存储系统（发布的消息先存起来）。Kafka 比别的系统的优势在于
它是一个非常高性能的`存储系统`。

写入到 Kafka 的数据将写到磁盘并复制到集群中保证容错性。并允许生产者等待消息应答，知道消息完全写入。

Kafka 的磁盘结构，无论服务器上有 50KB 或者有 50TB， 执行是相同的。（？）

client 来控制读取数据的位置。

还可以认为 Kafka 是一种专用于高性能，低延迟，提交日志存储，复制和传播特殊用途的`分布式文件系统`。

### Kafka 的流处理

仅仅读，写和存储是不够的，kafka的目标是实时的流处理。

在kafka中，流处理持续获取输入topic的数据，进行处理加工，然后写入输出topic。例如，一个零售APP，接收销售和出货的输入流，统计数量或调整价格后输出。

可以直接使用producer和consumer API进行简单的处理。对于复杂的转换，Kafka提供了更强大的Streams API。可构建聚合计算或连接流到一起的复杂应用程序。

助于解决此类应用面临的硬性问题：处理无序的数据，代码更改的再处理，执行状态计算等。

Sterams API在Kafka中的核心：使用producer和consumer API作为输入，利用Kafka做状态存储，使用相同的组机制在stream处理器实例之间进行容错保障。